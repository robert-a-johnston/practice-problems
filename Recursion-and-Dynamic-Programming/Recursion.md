### How to Approach
- BOTTOM UP
  - Solve for simple use case
  - build the solution for one and keep adding additional solutions
- TOP DOWN
  - divide the problem into sub-problems
  - make sure the sub-problems don't overlap
- HALF-AND-HALF
  - Divide the data set in half
  - binary search and merge sort
### Dynamic Programming and Memoization
- DYNAMIC PROGRAMMING
  - taking a recursive algorithm and finding the overlapping sub-problems(repeated calls).  Then you cache those results for future recursive calls.